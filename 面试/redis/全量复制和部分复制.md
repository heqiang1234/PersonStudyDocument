更多会问如何用sortedset实现延时队列、实现分布式锁之类的，这些在项目里非常常用。进阶会问bloomfilter原理，epoll原理，redis rehash这些





全量复制 和部分复制

Psync支持全量和部分复制

Psync [runid] [offset]



**runId**：每个redis节点启动后都会生成唯一的uuid，每次Redis重新启动，这个值会变化

**offset**：偏移量，主节点和从节点都会各自维护自己的主从复制偏移量，ofsset = offset + 命令的字节长度，从节点收到主节点发送的命令后，也会增加自己的offset，并把自己的offset发送给主节点，

主节点会同时保存自己的offset和从节点的offset，通过对比offset来对比主从节点的数据，默认带下是是否一致。

**repl_backlog_size**：保存在主节点上的先进先出的队列，默认大小是 1M



主节点发送数据给从节点的时候，主节点还会进行写操作，但是会把这些命令保存进复制缓冲区中。

从节点同步主节点数据完成后，主节点会将缓存区的数据继续发送给从节点（要发送的数据区间，从offset来决定），用于部分复制。

主节点响应命令的时候，不但会把命名发送给从节点，还会写入复制积压缓冲区，用于复制命令的丢失的补救。



从节点发送psync[runid] [offset]命令时，主节点有三种响应

- FULLSYNC：第一次连接，进行全量复制
- CONTINUE：进行部分复制
- ERR：不支持psync命令，进行全量复制



全量复制

- 从节点发送psync[?] [offset] 命令给主节点，
- 主节点接收到后，查看offset偏移量，发现是第一次复制，返回全量复制 FULLSYNC [runid] [offset] , runid为主节点的runid，offset是主节点的偏移量
- 主节点收到后，保存主节点的runid信息
- 主节点在发送全量复制的 FULLSYNC的命令后，就会执行bgsave命令，持久化出RDB文件。
- 主节点将RDB文件发送给从节点，从节点会将RDB文件执行，实现数据复制，在发送数据给从节点的时候，此时主节点进行的写命令等会写入复制缓存区。
- 从节点清理自己的数据
- 从节点执行RDB文件，将数据保存进自己的数据库。如果从节点开启了AOF，会异步执行AOF文件。