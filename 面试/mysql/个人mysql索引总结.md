个人mysql索引总结：

## 什么是索引：

索引是一种数据结构，可以



## 索引的优缺点：

### 优点：

可以提高数据库查询的速度，提高性能。

具体的原因是，使用了索引后，数据会是一种有序状态，假设我们需要查询 age>20的数据，如果没有使用索引，那么我们的处理逻辑是，数据库服务端，发送指令到存储引擎，存储引擎全表扫描，将所有的记录都返回到服务端，服务端这边进行筛选，然后生成临时表，进行排序，然后返回结果集，如果使用索引了，那么处理逻辑就变为，数据服务端发送指令到存储引擎，存储引擎先查询对应的索引表，（数据结构，B+树，后面介绍），这里可以直接获取到有序的数据地址，然后返回数据，这里的操作和没有索引相比较，减少了返回数据的大小，降低服务器的压力，最根本的是减少了磁盘IO，扫描全表是一条条数据的查，使用了索引后，由于索引使用的B+树结构，降低了扫描查询的深度，

### 缺点：

表索引占用了一定的空间，

添加了索引之后，如果进行了增删改操作后，我们的索引需要进行重建，如果索引数量很大的话，重新构造需要的时间很长。会一定程度的降低增删改的性能。



## 索引的分类：

### 按照数据结构来分：

#### hash结构：

mysql并没有显示支持hash索引，而是作为一种内部的优化，innodb会监控对上的二级索引的查找，如果发现某二级索引被频繁访问（会监控访问的次数，达到一定的次数，就会建立hash索引），就会建立hash索引，被称为（自适应hash索引），

使用了哈希表来实现，key-value存储，存储的一般是主键，或者唯一的值，这种索引结构进行单记录查询的时候速度很快，因为可以直接通过key定位到数据。（还有没有其他思路），在mysql后续的版本都是会进行隐性转换为hash索引的，因为 热点数据查询很频繁，使用hash索引查询很快。

#### B+树结构：

使用的B+树结构实现。几乎所有的索引都是用B+树实现的，除了全文索引是使用跳表实现，hash索引是使用hash表实现。



### 按照是否是主键来分

#### 主键索引：

MYSQL是根据主索引组织数据的，所以每张表都必须有主键索引，并且主键索引只有一个，如果没有创建，会有一个隐性字段row_id作为主键，创建主键索引。

如果创建了主键索引，那么这个索引会当作聚簇索引。



#### 普通索引：

如果不是主键索引，那么可以称之为非主键索引，也称之为辅助索引或者二级索引，主键索引存储的是完整的数据，而非主键索引存储的是主键索引值，通过非主键索引查询数据时，我们是先通过非主键索引查询到主键索引值，然后通过这个值去主键索引查询对应的数据。

正常的话，查询分两步：

第一步是按照辅助索引查询到记录的主键值。

第二步是按照主键值在主键索引里面找记录，返回数据。



### 按照索引字段个数划分

#### 单值索引：

单个字段组成的索引称为单值索引



#### 多值索引，复合索引，组合索引：

多个字段组成的索引称为复合索引。

符合索引遵循最左前缀匹配原则，所以复合索引的顺序很重要，只有满足左边索引字段才会按照从左到右的顺序去匹配后续的索引字段，这里就存在索引失效的风险，后续讲解。所以我们建立符合索引的时候，一般将访问频繁的字段放在前面。这里存在一个覆盖索引的现象，当我们查询的字段都是索引的字段，那么我们可以直接通过索引得到值，不用再次去回表查询。还存在一个索引下推ICP的处理,这个是自己配置是否开启。设置 index_condition_pushdown = no，如果我们设置了一个索引。索引的字段是(a,b)，我们查询的时候，索引字段的匹配的顺序是a,然后b,如果此时进行范围 查询例如“a%”,那么此时右边索引不会被使用，因为模糊匹配，不能将所有的字段命中，所以此时后续的字段不能使用，正是针对这种情况，所以推出了MYSQL5.6索引下推，可以针对所有的后续索引字段，优先进行where的匹配处理，减少了回表查询的次数。



### 根据数据与索引的存储关联 性划分

#### 聚簇索引：





#### 非聚簇索引：







**科普时间——查询优化器** 一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。 在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。 优化过程大致如下： 1、根据搜索条件，找出所有可能使用的索引 2、计算全表扫描的代价 3、计算使用不同索引执行查询的代价 4、对比各种执行方案的代价，找出成本最低的那一个
