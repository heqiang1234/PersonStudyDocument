

## **1.** **什么是索引？**

索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。

索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。



## 2. 索引的分类

- 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。
- 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。
  - 可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引
  - 可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引

- 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值
  - 可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引
  - 可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引

- 全文索引：是目前搜索引擎使用的一种关键技术。
  - 可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引

## 索引的优缺点

为什么要创建索引？  这是因为，**创建索引可以大大提高系统性能。**

### 索引的优点：

- 通过创建索引，可以大大提高数据的检索速度，这也是创建索引的最主要原因

- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

索引的缺点：

- 虽然索引大大提高了查询速度，但同时却会降低更新表的速度，如对表进行insert、update、delete。==因为更新表时，MYSQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。==。
- 建立索引会占用磁盘空间的索引文件。一般情况下这个问题不是太严重，但是如果你在一个大表创建了多种组合索引，索引文件会膨胀很快。
- 如果某个数据列中包含许多重复的内容，为它建立索引就没有太大实际效果。

-  时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；

- ·空间方面：索引需要占物理空间。



## **索引执行：**

DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度,如果是重复数据就没有什么意义了



## **索引失效**          ==模型数空运最快==

- 全值匹配

- 最佳左前缀法则 - 如果索引了多列，要遵守最左前缀法则，指的是查询从索引的最左前列开始并且不跳过索引中的列。

- 索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描
- 存储引擎不能使用索引中范围条件右边的列
- 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *
- mysql在使用不等于的时候无法使用索引会导致全表扫描
- is null,is not null也无法使用索引
- Like以通配符开头，mysql索引失效
- 字符串不加单引号索引失败
- 少用or,用它连接时会索引失败‘

模型数空运最快

**模：** 如果我们like查询的时候使用了 %时，索引会失效，因为如果我们是索引查询是 '%hq'，这个等价于 xxhq,前面两个字母是未知的，那么我们此时就使用了全表遍历了，因为未知值，无法比较。我们不能连续的获取到某部分数据，如果是 ‘hq%’，我们是先查找 hq 这个字符串，这个字符串在索引里面也是按照大小排序，可以锁定到一部分数据，所以我们可以使用索引去查找数据。我们要确保前面的是有序的，和最佳左前缀法则相似，只有前面的是有序的，我们才能去查找后面的数据，在有序的基础上，才能查找。

**型**：数据类型，如果数据类型取错了，也会索引失效，等价于函数，因为数据类型不对，mysql就要进行隐性的转换，这里就要使用函数进行转换，使用函数，要先取数据，在进行处理，那么我们就无法在取数据的时候，使用索引获取数据

**数：**函数，如果我们使用函数，例**where month(t_modified)=7**，那我们等价于先取存储引擎里面取数据 t_modified,然后进行month的转换操作，最后拿过来和 7 进行比较，这样我们在最开始从存储引擎取数据时，根本不知道取什么样的数据出来，这样就需要全表遍历，没有走索引

**空：**如果我们的索引存在空值，进行了为null的判断，那么此时的索引会失效，因为我们的索引会将所以你的值，按照大小进行排序，分配到树的对应叶节点，这样的操作是要进行比较的，如果为0，那么此时就不知道这个null的数据放在哪里，所以索引就找不到，找不到的话，mysql会进行全表扫描查找。

**运：**索引列有数据运算的时候不能使用索引

最：最佳左前缀法则，如果是复合索引，我们在索引里面排序是先按照第一个索引字段排序，然后第二个字段排序，如果我们第一个没有走索引，那么我们获取的数据是无序的， 就无法去通过第二个字段去获取到有序的数据，从而全表遍历，索引失效。

**快：**如果优化器认为使用全表比使用索引快，那就不会使用索引，说白了就是基于优化器或者统计信息，这个就是所谓的百分比，这里最重要的一点是使用索引一般情况下是回表，也就是发生随机IO,这个随着回表的量的大小变大，一般OLTP都是在表下查询少量数据情况，所以还是使用索引的情况会好



### MySQL索引失效的几种情况详析

**1.前导模糊查询不能利用索引(like '%XX'或者like '%XX%')**

假如有这样一列code的值为'AAA','AAB','BAA','BAB' ,如果where code like '%AB'条件，由于前面是

模糊的，所以不能利用索引的顺序，必须一个个去找，看是否满足条件。这样会导致全索引扫描或者全表扫

描。如果是这样的条件where code like 'A % '，就可以查找CODE中A开头的CODE的位置，当碰到B开头的

数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。

**2.如果是组合索引的话，如果不按照索引的顺序进行查找，比如直接使用第三个位置上的索引而忽略第一二个位置上的索引时，则会进行全表查询**

索引为c1,c2,c3,c4

上图结果显示直接使用c3是全表查询，无法使用该索引的，所以c3字段使用索引的前提是c1，c2两字段均使用了索引。

**3.条件中有or**

应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：

```sql
select id from t where num=10 or num=20
```

可以这样查询：

```sql
select id from t where num=10 union all select id from t where num=20
```

**4.索引无法存储null值，所以where的判断条件如果对字段进行了null值判断，将导致数据库放弃索引而进行全表查询，如**

```sql
select id from t where num is null
```

可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：

```sql
select id from t where num=0
```

a.单列索引无法储null值，复合索引无法储全为null的值。

b.查询时，采用is null条件时，不能利用到索引，只能全表扫描。

**为什么索引列无法存储Null值？**

a.索引是有序的。NULL值进入索引时，无法确定其应该放在哪里。（将索引列值进行建树，其中必然涉及到诸多的比较操作，null 值是不确定值无法比较，无法确定null出现在索引树的叶子节点位置。）

**5.应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。**

**6.in 和 not in 也要慎用，否则会导致全表扫描，如：**

```sql
select id from t where num in(1,2,3)
```

对于连续的数值，能用 between 就不要用 in 了：

```sql
select id from t where num between 1 and 3
```

**7. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：**

–name以abc开头的id

```sql
select id from t where substring(name,1,3)='abc'
```

**8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：**

```sql
select id from t where num/2=100
```

应改为:

```sql
select id from t where num=100*2
```

## **索引文件：**

1.frm文件：存放表结构
2.myd文件：存放表数据
3.myi文件：存放表索引



## 索引的数据结构 （b树，hash）

索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的==InnoDB存储引擎的默认索引实现为：B+树索引==。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

