

## 索引的优缺点



索引的缺点：

- 虽然索引大大提高了查询速度，但同时却会降低更新表的速度，如对表进行insert、update、delete。==因为更新表时，MYSQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。==。
- 建立索引会占用磁盘空间的索引文件。一般情况下这个问题不是太严重，但是如果你在一个大表创建了多种组合索引，索引文件会膨胀很快。
- 如果某个数据列中包含许多重复的内容，为它建立索引就没有太大实际效果。



## **索引执行：**

DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度,如果是重复数据就没有什么意义了



## **索引失效**          ==模型数空运最快==

- 全值匹配

- 最佳左前缀法则 - 如果索引了多列，要遵守最左前缀法则，指的是查询从索引的最左前列开始并且不跳过索引中的列。

- 索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描
- 存储引擎不能使用索引中范围条件右边的列
- 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *
- mysql在使用不等于的时候无法使用索引会导致全表扫描
- is null,is not null也无法使用索引
- Like以通配符开头，mysql索引失效
- 字符串不加单引号索引失败
- 少用or,用它连接时会索引失败‘

模型数空运最快

**模：** 如果我们like查询的时候使用了 %时，索引会失效，因为如果我们是索引查询是 '%hq'，这个等价于 xxhq,前面两个字母是未知的，那么我们此时就使用了全表遍历了，因为未知值，无法比较。我们不能连续的获取到某部分数据，如果是 ‘hq%’，我们是先查找 hq 这个字符串，这个字符串在索引里面也是按照大小排序，可以锁定到一部分数据，所以我们可以使用索引去查找数据。我们要确保前面的是有序的，和最佳左前缀法则相似，只有前面的是有序的，我们才能去查找后面的数据，在有序的基础上，才能查找。

型：数据类型，如果数据类型取错了，也会索引失效，等价于函数，因为数据类型不对，mysql就要进行隐性的转换，这里就要使用函数进行转换，使用函数，要先取数据，在进行处理，那么我们就无法在取数据的时候，使用索引获取数据

**数：**函数，如果我们使用函数，例**where month(t_modified)=7**，那我们等价于先取存储引擎里面取数据 t_modified,然后进行month的转换操作，最后拿过来和 7 进行比较，这样我们在最开始从存储引擎取数据时，根本不知道取什么样的数据出来，这样就需要全表遍历，没有走索引

**空：**如果我们的索引存在空值，进行了为null的判断，那么此时的索引会失效，因为我们的索引会将所以你的值，按照大小进行排序，分配到树的对应叶节点，这样的操作是要进行比较的，如果为0，那么此时就不知道这个null的数据放在哪里，所以索引就找不到，找不到的话，mysql会进行全表扫描查找。

**运：**null.

最：最佳左前缀法则，如果是复合索引，我们在索引里面排序是先按照第一个索引字段排序，然后第二个字段排序，如果我们第一个没有走索引，那么我们获取的数据是无序的， 就无法去通过第二个字段去获取到有序的数据，从而全表遍历，索引失效。

**快：**



### MySQL索引失效的几种情况详析

**1.前导模糊查询不能利用索引(like '%XX'或者like '%XX%')**

假如有这样一列code的值为'AAA','AAB','BAA','BAB' ,如果where code like '%AB'条件，由于前面是

模糊的，所以不能利用索引的顺序，必须一个个去找，看是否满足条件。这样会导致全索引扫描或者全表扫

描。如果是这样的条件where code like 'A % '，就可以查找CODE中A开头的CODE的位置，当碰到B开头的

数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。

**2.如果是组合索引的话，如果不按照索引的顺序进行查找，比如直接使用第三个位置上的索引而忽略第一二个位置上的索引时，则会进行全表查询**

索引为c1,c2,c3,c4

上图结果显示直接使用c3是全表查询，无法使用该索引的，所以c3字段使用索引的前提是c1，c2两字段均使用了索引。

**3.条件中有or**

应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：

```sql
select id from t where num=10 or num=20
```

可以这样查询：

```sql
select id from t where num=10 union all select id from t where num=20
```

**4.索引无法存储null值，所以where的判断条件如果对字段进行了null值判断，将导致数据库放弃索引而进行全表查询，如**

```sql
select id from t where num is null
```

可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：

```sql
select id from t where num=0
```

a.单列索引无法储null值，复合索引无法储全为null的值。

b.查询时，采用is null条件时，不能利用到索引，只能全表扫描。

**为什么索引列无法存储Null值？**

a.索引是有序的。NULL值进入索引时，无法确定其应该放在哪里。（将索引列值进行建树，其中必然涉及到诸多的比较操作，null 值是不确定值无法比较，无法确定null出现在索引树的叶子节点位置。）

**5.应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。**

**6.in 和 not in 也要慎用，否则会导致全表扫描，如：**

```sql
select id from t where num in(1,2,3)
```

对于连续的数值，能用 between 就不要用 in 了：

```sql
select id from t where num between 1 and 3
```

**7. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：**

–name以abc开头的id

```sql
select id from t where substring(name,1,3)='abc'
```

**8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：**

```sql
select id from t where num/2=100
```

应改为:

```sql
select id from t where num=100*2
```

## **索引文件：**

1.frm文件：存放表结构
2.myd文件：存放表数据
3.myi文件：存放表索引

