# JVM

## 类加载机制

类加载： java虚拟机类加载过程是把Class类文件加载到内存，并对Class文件中的数据进行校验、转换、解析和初始化，最终形成可以被虚拟机直接使用的java类型的过程

![](https://img-blog.csdnimg.cn/img_convert/881c5b0064256b4adb4abeccd3ad9a01.png)

```xml
装载：
1.ClassFile --> 字节流 --> 类加载器
2.将字节流代表的静态存储结构转换成方法区的运行时数据结构
3.入口，在我们的java堆中生成一个代表这个类的java.lang.class对象，作为我们的方法区中对应的数据访问入口
```

```xml
链接：
1. 验证 你这个文件不能有问题
2. 准备 为类的静态变量开辟内存，并赋予当前类型的默认值
private static int a = 1;    a = 0;先赋值int的默认值0，
3. 解析 解析是从运行时常量池中的符号引用动态确定具体值的过程。
== 符号引用 转变为 直接引用

4. 初始化  classInit方法   a = 1; 初始化静态代码块  初始化它的父类 ....
```

```java
类加载器  Classloder

java.lang.String        源码.rt.jar
java.lang.String        classpath 业务代码自己定义的


问题： 想办法
```

java1.2前只有一个类加载器

```java
操作数 栈

存储操作数
```

```java
动态链接将这些符号方法引用转换为具体的方法引用
符号引用转变为直接引用

void a(){
    b();
}

void b(){
    c();
}

void c(){
   xxx;
}


   native方法，程序计数器不记录方法
```

## 双亲委派机制

## 沙盒哼安全机制

## java堆











# 垃圾回收机制

```java
回收哪分析算法/：
判定：我回收的数据 对象的回收




内存泄漏     的堆积  会产生内存溢出问题引用计数法 执行的效率非常高， 但是难以解决对象的循环引用问题


可达性分析算法/根搜索算法，    可达性  GC root 引用出一条引用链 引用链上的对象 便是存货的对象
可作为GC root：JNI  局部变量表中元素，   
静态变量/常量
 相当于一组活跃的引用

什么时候进行回收
1.Eden区满了之后，S区满了之后，  young GC
2.老年代空间不够  Old GC
方法区空间不够  Meta Space GC
4.System.gc()  //通知进行一次垃圾回收   full GC
执行System.gc()函数的作用只是提醒或告诉虚拟机，希望进行一次垃圾回收。
至于什么时候进行回收还是取决于虚拟机，而且也不能保证一定进行回收（如果-XX:+DisableExplicitGC设置成true，则不会进行回收）。

然后在简单说一下什么样的对象会被gc()回收：sum的hotspot虚拟机是通过可达性分析算法来判断对象是否需要回收。
——————————

垃圾回收   简单  高效  健壮
stop the world 停顿时间
垃圾回收算法执行的时候，停止业务线程的运行，
1.标记清除算法
停止 STW ，
标记： 遍历GC root的引用链 ，在引用链上面标记为存活状态，其他的都需要被清除      
清除： 清除未被标记的对象
1.导致 STW （影响体验） 其次 效率慢  内存碎片  ？JVM需要维护一个空闲内存列表？

2.复制算法（标记复制算法）
空间换时间    肯定不能用在整个内存空间，因为损耗空间太大
将内存一分而二，每次使用半个内存，将存活的对象移动到另一半块，然后将这半块直接清除。

3.标记整理算法     标记清除整理算法  效率 <= 标记清楚   现代的整理算法（单独）

标记：
整理：

三种整理算法：
随机整理：
线性整理：
滑动整理（现在大部分使用的）：  一边清除，一边整理    
派出两根指针  ，一根指针找到空闲地址，或非存活对象，另一指针找存活区域，交换对应的空间
两个指针碰到一起后，后面的区域全部删除。  （滑动整理效率不会大于清除算法效率）

分代收集算法：
根据对象的存活周期不同，划分为几块
young区

old区，标记整理或者标记清除



垃圾收集器：
基于垃圾回收机制的落地：
  ((串行GC))
《serial》:  JDK 1.3.1 单线程（STW） 复制算法 很高的单线程收集效率很高

《serial Old》 :  单线程  标记整理算法，（运行过程和serial类似） 

Stw（历史原因，当时没有考虑到现在频繁交互使用的场景） 嵌入式 CPU单核    95年立项  改名为java 

完善 STW时间长，  单线程 -- 多线程 

《parNew》
多个垃圾收集线程

STW  多线程缩短停顿时间的情况下，完全的去掉停顿时间的代价非常大  用户没有感知
关注  吞吐量   系统一天能够去干的事情  ，单位时间响应请求的速度  能不能控制

吞吐量 =  业务代码时间  / （业务代码时间 + 垃圾收集时间）     99/100 = 99% 

((并行GC))
Parallel Scavenge   多线程
Parallel Old  老年代  标记整理算法    1.吞吐量   2.停顿时间


交互式应用  保证停顿时间 300ms情况下  尽可能 增加吞吐
如果是常规应用 需要在保证最大吞吐量的情况下， 尽可能减小停顿时间


JVM调试调优就是 吞吐量和停顿时间的交换?
95%以上   现在吞吐 98%   500 ms   如果 1% 吞吐可以换来200ms的停顿时间，可以换  GC view 查看吞吐量

停顿时间消完，垃圾收集线程 + 业务线程 （这样就不存在停顿时间）

微软公司 《C4》 提供一款 可以完全解决停顿时间的垃圾回收器

垃圾收集线程 + 业务线程  我应该保证不出问题  尽可能减少耗时操作  去进行 垃圾收集线程 + 业务线程

并发类垃圾收集器

《MS》  标记清除算法  缩短停顿时间  不关注内存碎片   （三色标记）？？
标记清除算法    分治算法
标记
1.初始标记：找到所有的GC root 以及与之直接相关联的对象  不耗时   STW
2.并发标记：找到引用链上的所有对象  并且进行标记     耗时   并发 垃圾手机线程 + 业务线程
3.重新标记：增量标记那些依赖关系发生变化的对象   不耗时  STW
4.并发清除      耗时  发 垃圾手机线程 + 业务线程    后面会整理

JDK 7 初始标记 单线程
JDK 8 初始标记 多线程
HotSpot 源码看一下

G1   garbage first  （非停顿时间优先，是垃圾清除优先）
1.我能有更短的垃圾收集时间   想多短就多短   =可以自己设置=   并发失败  直接进入 full gc
2.=某种程度=上可以解决空间碎片，  2048个region的区域 1M-32M  空间碎片解决是重新定义内存
假设我们去进行  垃圾收集   大的垃圾场  10台卡车   保证能正常运行


Z GC
支持缩减到10ms以内
4TB


```



## jvm 性能优化

```textile
JVM性能优化
1.代码层面  封装 
2.非代码层面

OOM ： out of memory 内存不够用了（调整young old内存空间大小）   4c8G  根本没有意义  分布式微服务  秒杀  促销
  限流  动静分离   线程池   负载均衡  Mysql性能优化  缓存  队列 内存泄漏
GC频繁  
CPU飙升


YOUNG区的大小  3000M    一个对象 24M   3000 * 0.8 /24 = 100s

内存泄漏和内存溢出什么区别

生产的经验  无非就是这些流程 1. 2. 3. 4.
 
JVM性能优化   Mysql性能优化    Tomact性能优化 Nginx性能优化  微服务性能优化


.
```
